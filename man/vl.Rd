% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/functions.R
\name{vl}
\alias{vl}
\title{vl}
\usage{
vl(
  p,
  q,
  adj = TRUE,
  indices = NULL,
  at = NULL,
  mode = 0,
  fold = NULL,
  nt = 5000,
  nv = 1000,
  p_threshold = 0,
  scale = c("p", "z"),
  closed = TRUE,
  verbose = FALSE,
  gx = 10^-5
)
}
\arguments{
\item{p}{principal p-values}

\item{q}{conditional p-values}

\item{adj}{adjust cFDR values and hence curves L using estimate of Pr(H0|Pj<pj)}

\item{indices}{instead of at cfdr cutoffs, compute v(L) at indices of points. Overrides parameter at if set.}

\item{at}{cfdr cutoff/cutoffs. Defaults to null}

\item{mode}{determines set of variables to use for computing cFDR. Set to 0 to leave all of 'indices' in, 1 to remove each index one-by-one (only when computing the curve L for that value of (p,q)), 2 to remove all indices in variable 'fold' and compute curves L only using points not in 'fold'}

\item{fold}{If mode=2, only compute L-curves using points not in 'fold'.}

\item{nt}{number of test points in x-direction, default 5000}

\item{nv}{resolution for constructing L-curves, default 1000}

\item{p_threshold}{if H0 is to be rejected automatically whenever p<p_threshold, include this in all regions L}

\item{scale}{return curves on the p- or z- plane. Y values are equally spaced on the z-plane.}

\item{closed}{determines whether curves are closed polygons encircling regions L (closed=T), or lines indicating the rightmost border of regions L}

\item{verbose}{print progress if mode=1}
}
\value{
list containing elements x, y. Assuming n curves are calculated (where n=length(indices) or length(at)) and closed=T, x is a matrix of dimension n x (4+nv), y ix a vector of length (4+nv).
}
\description{
Return co-ordinates of L-regions for cFDR method, with or without estimation of Pr(H0|Pj<pj).
}
\details{
Parameter 'mode' defines the way in which L-curves are constructed. L-curves define a mapping 
from the unit square [0,1]^2 onto the unit interval [0,1], and we consider the mapped values 
of each point (p[i],q[i]). In this method (cFDR1) the mapping depends on the points used to 
generate L, and if these points coincide with the points we are using the map for, the 
behaviour of the map is very complicated. Parameter 'mode' governs the set of points used in 
generating L-curves, and can be used to ensure that the points used to define curves L (and 
hence the mapping) are distinct from the points the mapping is used on.
}
\examples{
# Generate standardised simulated dataset
set.seed(1); n=10000; n1p=100; n1pq=100; n1q=100
zp=c(rnorm(n1p,sd=3), rnorm(n1q,sd=1),rnorm(n1pq,sd=3), rnorm(n-n1p-n1q-n1pq,sd=1))
zq=c(rnorm(n1p,sd=1), rnorm(n1q,sd=3),rnorm(n1pq,sd=3), rnorm(n-n1p-n1q-n1pq,sd=1))
p=2*pnorm(-abs(zp)); q=2*pnorm(-abs(zq))
fold_id=(1:n) \%\% 3


# points to generate L-regions for
example_indices=c(4262, 268,83,8203)



par(mfrow=c(1,3))

v1=vl(p,q,indices=example_indices,mode=0,nv=5000); 
plot(p,q,cex=0.5,col="gray",xlim=c(0,0.001),ylim=c(0,1), main="All points in"); 
for (i in 1:length(example_indices)) lines(v1$x[i,],v1$y); 
for (i in 1:length(example_indices)) points(p[example_indices[i]],q[example_indices[i]],qh=16,col="blue")

# L1_{S-fold} example (fold left out; all points are in fold 2). Spikes disappear.
v2=vl(p,q,indices=example_indices,mode=2,fold=which(fold_id==2)); 
plot(p,q,cex=0.5,col="gray",xlim=c(0,0.001),ylim=c(0,1),main="Fold removed"); 
for (i in 1:length(example_indices)) lines(v2$x[i,],v2$y); 
for (i in 1:length(example_indices)) points(p[example_indices[i]],q[example_indices[i]],pch=16,col="blue")

# L1_{S-(p,q)} example (each point left out of points used to generate curve through that point). Spikes disappear.
v3=vl(p,q,indices=example_indices,mode=1); 
plot(p,q,cex=0.5,col="gray",xlim=c(0,0.001),ylim=c(0,1), main="Single point removed"); 
for (i in 1:length(example_indices)) lines(v3$x[i,],v3$y); 
for (i in 1:length(example_indices)) points(p[example_indices[i]],q[example_indices [i]],pch=16,col="blue")

}
\author{
James Liley
}
