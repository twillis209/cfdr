% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/functions.R
\name{vlyl}
\alias{vlyl}
\title{vlyl}
\usage{
vlyl(
  p,
  q,
  indices = NULL,
  at = NULL,
  mode = 0,
  fold = NULL,
  p_threshold = 0,
  nt = 5000,
  nv = 1000,
  scale = c("p", "z"),
  closed = T,
  ...
)
}
\arguments{
\item{p}{principal p-values}

\item{q}{conditional p-values}

\item{indices}{compute v(L) at indices of points. Overrides parameter at if set.}

\item{at}{cfdr cutoff/cutoffs. Defaults to null}

\item{mode}{set to 0 to leave all of 'indices' in, 1 (NOT CURRENTLY SUPPORTED) to remove each index only when computing L at that point, 2 to remove all of 'indices' from p,q}

\item{fold}{If mode=2, only compute L-curves using points not in 'fold'.}

\item{p_threshold}{if H0 is to be rejected automatically whenever p<p_threshold, include this in all regions L}

\item{nt}{number of test points in x-direction, default 5000}

\item{nv}{resolution for constructing L-curves, default 1000}

\item{scale}{return curves on the p- or z- plane. Y values are equally spaced on the z-plane.}

\item{closed}{determines whether curves are closed polygons encircling regions L (closed=T), or lines indicating the rightmost border of regions L}

\item{...}{other parameters passed to function kde2d. Can be used to set a non-Gaussian kernel.}
}
\value{
list containing elements x, y. Assuming n curves are calculated and closed=T (where n=length(indices) or length(at)), x is a matrix of dimension n x (4+nv), y ix a vector of length (4+nv).
}
\description{
Return co-ordinates of L-regions for local cFDR using KDEs. Automatically includes an estimate of 
Pr(H0|Q<q).
}
\details{
Estimates empirical distribution of (P,Q) by fitting a kernel density estimate to observed values.
}
\examples{
# Generate standardised simulated dataset
set.seed(1); n=10000; n1p=100; n1pq=100; n1q=100
zp=c(rnorm(n1p,sd=3), rnorm(n1q,sd=1),rnorm(n1pq,sd=3), rnorm(n-n1p-n1q-n1pq,sd=1))
zq=c(rnorm(n1p,sd=1), rnorm(n1q,sd=3),rnorm(n1pq,sd=3), rnorm(n-n1p-n1q-n1pq,sd=1))
p=2*pnorm(-abs(zp)); q=2*pnorm(-abs(zq))
fold_id=(1:n) \%\% 3

# estimate parameters of underying dataset
fit_pars=fit.4g(cbind(zp,zq))$pars

# estimate parameters of underying dataset, removing fold 1
fit_pars_fold23=fit.4g(cbind(zp[which(fold_id!=1)],zq[which(fold_id!=1)]))$pars


# points to generate L-regions for
example_indices=c(4262, 268,83,8203)

par(mfrow=c(1,2))

v=vlx(p,q,pars=fit_pars,indices=example_indices); 
plot(p,q,cex=0.5,col="gray",xlim=c(0,0.001),ylim=c(0,1), main="All points in"); 
for (i in 1:length(example_indices)) lines(v$x[i,],v$y); 
for (i in 1:length(example_indices)) points(p[example_indices[i]],q[example_indices[i]],pch=16,col="blue")

v2=vlx(p,q,pars=fit_pars_fold23,indices=example_indices); 
plot(p,q,cex=0.5,col="gray",xlim=c(0,0.001),ylim=c(0,1), main="Fold removed"); 
for (i in 1:length(example_indices)) lines(v2$x[i,],v2$y); 
for (i in 1:length(example_indices)) points(p[example_indices[i]],q[example_indices[i]],pch=16,col="blue")


}
\author{
James Liley
}
